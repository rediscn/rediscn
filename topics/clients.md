---
layout: topics
title: REDIS clients -- Redis中文资料站
permalink: topics/clients.html
disqusIdentifier: topics_clients
disqusUrl: http://redis.cn/topics/clients.html
---

# Redis如何处理客户端连接 #

本文档提供有关Redis如何处理来自客户端的信息，从网络层来看包含以下几点：连接、超时、缓冲区以及一些其它类似的主题。
这篇文档所包含的信息 **仅仅适用于Redis的2.6或者更高版本。**

## 客户端的连接的建立 ##

Redis通过在TCP端口上进行监听，或者Unix socket（如果启用）的方式来接受客户端的连接。当一个新的客户端连接被接受执行以下操作：

+ 当Redis使用非阻塞I/O复用，客户端socket设置为非阻塞状态。
+ socket TCP_NODELAY属性被设置确保在连接中我们不会延迟。
+ 一个 可读的文件事件被创建，因而当新的数据可以被访问时，Reids可以更快接收客户端在socket上的查询

当客户端初始化后，Redis检查我们是否还在它可以同时处理的客户端的数量限制范围内(这个是使用 maxclients 配置指令配置的，请参阅本文档的下一节获取更多的信息。

如果它因为当前已经接受了最大数量的客户端，无法接受当前的客户端，Redis将尝试发送一个错误给客户端以便让其意识到这种情况，并且立即关闭连接。即使连接被Redis立即关闭，错误信息也会返回给客户端，因为新的socket输出缓冲区一般情况下都足够放下错误信息，因而客户端内核将处理连接错误。

## 客户端按照什么顺序被处理 ##

该顺序是由客户端socket文件描述符的数字大小及核心报告客户端事件的顺序决定的，因此顺序可以看成不确定的。
不过Redis给客户端提供服务时会做以下两件事:

+ 每次它从客户端socket读取新东西的时候它只执行一次 read() 系统调用，以确保当我们有多台客户端连接时，并且有一些要求高客户端以非常快的速率发送查询时，其它客户端不会因此而受到惩罚和经历一个糟糕的延时。（译者注：意思就是不读取完整个socket的消息，而是每个socket轮流读一次）
+ 当系统调用执行完，当前缓冲中的命令不管有多少都会被顺序处理。

## 最大数量的客户端 ##

在Redis 2.4中，同时处理的最大客户端数量的限制是硬编码的。

在Redis 2.6中这个限制是动态的：默认情况下为10000个客户端，除非在redis.conf中配置了maxclients配置项。

Redis通过检查内核中我们可以打开的最多的文件描述符数量，（soft limit被检查），如果限制小于最大连接客户端连接数，则加上32（这是Redis储备给内部使用的文件描述符数量）， 接着这个最大连接客户端的数量将被Redis修改为系统要求的值，以便符合在当前操作系统限制下的真正能够处理的客户端数量

当配置的最大客户端数目不起作用时，则日志将在启动时显示，如下面这个例子：


	$ ./redis-server --maxclients 100000
	[41422] 23 Jan 11:28:33.179 # Unable to set the max number of files limit to 100032 (Invalid argument), setting the max clients configuration to 10112.


当Redis配置处理客户的具体数量时，确认操作系统中每个进程文件描述符的限制也相应地设置成最大值是个好主意。
在Linux下这些限制可以在当前的会话设置，用下面的命令在系统范围内进行设置：

+ ulimit -Sn 100000 # 这个将只在硬限制足够大的情况下生效。
+ sysctl -w fs.file-max=100000

## 输出缓冲限制 ##
Redis需要为每个客户端处理可变长度的输出，因为简单的命令也可能产生一个需要传送给客户端的巨大的数据量。

也可能只是客户端以较快的速度发送多个的命令产生的更多的输出，当客户端处理新消息的速度比服务端发给给它的速度还慢时，特别是Pub/Sub客户端更是如此。

这两个原因将导致客户端输出缓冲增长及内存消耗增多。因为这个原因在默认情况下Redis为不同类型的客户端设置了输出缓冲限制。当限制到达后客户端的连接将被关闭，同时事件日志记录在Redis的日志文件中。

Redis使用两种类型的限制：

+ **硬限制**是个固定的限制，当大小达到它Redis会以最快的速度关闭掉客户端的连接。
+ **软限制**依赖于时间，例如每10秒32兆字节意味着加入客户端拥有比32兆字节还大的输出缓冲，持续的在10秒内超过的话连接将被关闭。
+ 
不同类型的客户端有着不同的默认限制：

+ **普通客户端**有着默认为0的限制，这意味着没有限制，因为大部分的普通客户端使用阻塞实现发送单个命令，并且在发送下一个命令前等待答复以完全读取，因此去关闭普通客户端的连接始终是没必要的。
+ **Pub/Sub客户端**有默认的32兆字节的硬限制及每60秒8兆字节的软限制。
+ **从机**有默认的256兆字节的硬限制及每60秒64兆字节的软限制。
+ 
可以在运行时改变这些限制，使用CONFIG SET命令或者修改redis.conf以永久地改变它。见redis.conf中更多的关于如何设置限制的介绍。

## 搜索缓冲硬限制 ##
每一个客户端也受到搜索缓冲限制。这是个不可配置的硬限制，当客户端搜索缓冲（这是个我们用来积累客户端的命令的缓冲）达到1GB的时候它将关闭连接，这只是个极限限制，用来避免当客户端或者服务端软件出错导致服务器崩溃的情况。

## 客户端超时 ##
最近版本的Reids在默认情况下不会在客户端空闲很久后关闭连接；连接将永久保留。
不过假如你不喜欢这种行为，你可以设置一个超时时间，这样当客户端空闲超过设置的几秒后，客户端连接就会被关闭。

你可以在redis.conf中配置这个限制或者简单的使用CONFIG SET timeout <value>。
记住这个超时时间只适用于多个客户端并且它不支持Pub/Sub客户端, Pub/Sub连接是推送类型的连接，因而客户端空闲是正常的。

即使在默认情况下连接是不受超时时间限制的，但是有两种情况设置超时是有意义的：

+ 关键任务应用，客户端软件可能因为Redis连接饱和而造成出错，造成服务中断。
+ 如果一个客户端出错使得服务器因为空闲连接而饱和，使得无法与服务器交互，此时可以作为一个检错机制去连接服务器。

超时并非非常准确：Redis避免设置计时器或者运行O(N) 算法去轮询检测客户端是否超时, 所以检查是渐近的一部分一部分完成的。这意味着有可能当超时时间设置为10秒，客户端的连接将在稍晚的时候被关闭，例如当很多客户端在同一时间连接的话，可能12秒才被关闭。

## 客户端命令 ##

Redis客户端命令允许检查所有连接的客户端的状态、关掉指定的客户端的连接、设置连接的名称。假如你使用一定规模的Redis的话这是个很强大的排错工具

CLIENT LIST命令用来获得连接的客户端列表及它们的状态：


	redis 127.0.0.1:6379> client list
	addr=127.0.0.1:52555 fd=5 name= age=855 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client
	addr=127.0.0.1:52787 fd=6 name= age=6 idle=5 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=ping


在上面的示例中两台客户端都连接到了Redis服务器。一部分有趣的字段的含义如下表所示：

+ **addr：**客户端地址，也就是客户端用来连接Redis服务器的IP和远程端口号
+ **fd：**客户端socket文件描述符数目。
+ **name：**客户端名称，由CLIENT SETNAME命令设置。
+ **age：**连接已经存在了多少秒。
+ **idle：**连接已经空闲了几秒。
+ **flags：**客户端的类型(N代表普通客户端, 查看[字段完整列表](/commands/client-list.html))。
+ **omem：**客户端输出缓冲占用的内存量。
+ **cmd：**最后执行的命令。
+ 
参考[CLIENT LIST](/commands/client-list.html)文档，查看完整的字段列表及它们的说明。

当你有了客户端的列表, 你可以很简单的使用CLIENT KILL命令带上客户端IP作为参数来关掉连接。

命令CLIENT SETNAME和CLIENT GETNAME可以用于设置和取得连接的名称。
